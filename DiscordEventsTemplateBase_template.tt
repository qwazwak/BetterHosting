<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ assembly name="Newtonsoft.Json" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ assembly name="System.Net.Http" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
    #nullable enable
    private static readonly TimeSpan maxFileAge = TimeSpan.FromHours(6);

    private const string cacheName = "DiscordClientEventsCache.json";

    public static string AutomaticNamespaceLine => $"namespace {AutomaticNamespace};";
    public static string AutomaticNamespace => System.Runtime.Remoting.Messaging.CallContext.LogicalGetData("NamespaceHint")?.ToString() ?? throw new InvalidProgramException("No SolutionDirectoryAvailable!");
    
    public static string SolutionDirectory => @"@@@SOLUTION_DIR@@@";
    private static string CacheFilePath => Path.Combine(SolutionDirectory, cacheName);

    private ReadOnlyCollection<EventNaming>? eventsList;
    public ReadOnlyCollection<EventNaming> EventsList
    {
        get
        {
            if(eventsList != null) return eventsList;
            string cacheFilePath = CacheFilePath;
            FileInfo file_info = new(cacheFilePath);
            if(file_info.Exists)
            {
                if(file_info.CreationTime <= DateTime.Now || (file_info.CreationTime - DateTime.Now) < maxFileAge)
                {
                    return eventsList = LoadEventsFromFile(cacheFilePath);
                }
            }

            var newResult = DownloadAndParse();
            SerializeToFile(newResult, cacheFilePath);
            eventsList = newResult;
            return newResult;
        }
    }

    private static ReadOnlyCollection<EventNaming> LoadEventsFromFile(string cacheFilePath)
    {
        try
        {
            string json;
            using (FileStream fs = File.OpenRead(cacheFilePath))
            using (StreamReader reader = new(fs))
            {
                json = reader.ReadToEnd();
            }
            return new(Newtonsoft.Json.JsonConvert.DeserializeObject<List<EventNaming>>(json));
        }
        catch(Exception ex)
        {
            throw new InvalidProgramException("Oops!", ex);
        }
    }
    private static void SerializeToFile(ReadOnlyCollection<EventNaming> events, string cacheFilePath)
    {
        string json = Newtonsoft.Json.JsonConvert.SerializeObject(events, Formatting.Indented);
        using (FileStream fs = new(cacheFilePath, FileMode.Create, FileAccess.Write))
        using (StreamWriter writer = new(fs))
        {
            writer.Write(json);
        }
    }
    private static ReadOnlyCollection<EventNaming> DownloadAndParse()
    {
        const string downloadURL = "https://raw.githubusercontent.com/DSharpPlus/DSharpPlus/master/DSharpPlus/Clients/DiscordClient.Events.cs";

        Regex regex = new("^ *public event AsyncEventHandler<DiscordClient, (?<EventArgType>.+?)> (?<EventName>.+?)$");
        using HttpClient client = new();

        Stream stream = client.GetStreamAsync(downloadURL).GetAwaiter().GetResult();
        IEnumerable<string> lines = StreamToLines(stream);
        IEnumerable<Match> matches = lines.Select(l => regex.Match(l)).Where(m => m.Success);
        return matches.Select(m => new EventNaming(m.Groups["EventName"].Value, m.Groups["EventArgType"].Value)).ToList().AsReadOnly();

        static IEnumerable<string> StreamToLines(Stream input)
        {
            using System.IO.StreamReader reader = new System.IO.StreamReader(input);
            string? line;
            while ((line = reader.ReadLine()) != null)
                yield return line;
        }
    }

    public struct EventNaming
    {
        public EventNaming(string eventName, string argumentType)
        {
            EventName = eventName;
            ArgumentType = argumentType;
        }
        public string EventName { get; private set; }
        public string ArgumentType { get; }
        public string MethodName => $"On{EventName}";
        public string InterfaceName => $"I{EventName}EventHandler";
        public string WithHandlerSuffix => $"{EventName}Handler";
    }
#>
