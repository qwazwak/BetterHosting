<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="System.Net.Http" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
#define AsyncManualResetEventNoValue
<#
Setup();
RemoveOne("#define AsyncManualResetEventWithValue");
sourceLines.RemoveAll(l => l.Contains("@@AsyncManualResetEventWithValue@@"));

ReplaceSubString("ValueTask.FromResult(value)", "ValueTask.CompletedTask");
substringsToRemove.ForEach(sr => ReplaceSubString(sr, string.Empty));
//Print bulk
sourceLines.ForEach(WriteLine);
#>
<#+
    // Config
    const string GenericFileName = "OneTimeAsyncEvent.Generic.cs";

    List<string> substringsToRemove = new()
    {
        "<T>",
        "{T}",
        "T value"
    };
    // end config
        
    List<string> sourceLines;

    //helpers: 
    void Setup()
    {
        string CurrentDir = Host.ResolvePath(string.Empty);
        string SourceFile = Path.Combine(CurrentDir, GenericFileName);
        sourceLines = new(File.ReadAllLines(SourceFile));
    }


    void MutateLines(Func<string, string> mutate)
    {
        for (int i = 0; i < sourceLines.Count; i++)
            sourceLines[i] = mutate(sourceLines[i]);
    }
    void ReplaceSubString(string substringMatch, string substringInsert) => MutateLines(s => s.Replace(substringMatch, substringInsert));

    void RemoveOne(string match)
    {
        if(!sourceLines.Remove(match))
            throw new ArgumentException($"The string {match} was not found in the source", match);
    }
#>