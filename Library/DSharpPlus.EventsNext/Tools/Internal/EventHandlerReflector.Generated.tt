<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ include file="../../../DiscordEventsTemplateBase.tt" #>
<#@ assembly name="System.Core" #>
using DSharpPlus.EventArgs;
using System.Diagnostics;
using DSharpPlus.EventsNext.Entities;
using System;
using DSharpPlus.AsyncEvents;
using System.Threading.Tasks;
using System.Collections.Generic;

<#=AutomaticNamespaceLine#>

internal static partial class EventHandlerReflector
{
    public static partial IEnumerable<Type> GetInterfaces<THandlerImplementation>() where THandlerImplementation : IDiscordEventHandler
    {
<# foreach(EventNaming naming in EventsList) { #>
        if(typeof(THandlerImplementation).IsAssignableTo(typeof(<#=naming.InterfaceName#>)))
            yield return typeof(<#=naming.InterfaceName#>);
<#}#>
    }

    public static partial ValueTask AutoCallEventHandler<THandler, TArgument>(IDiscordEventHandler<TArgument> handler, DiscordClient sender, TArgument args) where THandler : IDiscordEventHandler<TArgument> where TArgument : DiscordEventArgs
    {
<# foreach(EventNaming naming in EventsList) { #>
        if(typeof(THandler) == typeof(<#=naming.InterfaceName#>))
        {
            Debug.Assert(typeof(TArgument) == typeof(<#=naming.ArgumentType#>));
            <#=naming.InterfaceName#> castHandler = (<#=naming.InterfaceName#>)handler;
            <#=naming.ArgumentType#> castArgs = (<#=naming.ArgumentType#>)(DiscordEventArgs)args;
            return castHandler.<#=naming.MethodName#>(sender, castArgs);
        }
        else
<#}#>
        {
            Debug.Fail($"Not a supported type: {typeof(THandler).Name}");
            return ValueTask.FromException(new InvalidOperationException($"Handler of type {typeof(THandler).Name} not supported"));
        }
    }

    public static partial void BindEvent<THandlerInterface, TArgument>(DiscordShardedClient client, AsyncEventHandler<DiscordClient, TArgument> handler) where THandlerInterface : IDiscordEventHandler<TArgument> where TArgument : DiscordEventArgs
    {
<# foreach(EventNaming naming in EventsList) { #>
        if(typeof(THandlerInterface) == typeof(<#=naming.InterfaceName#>))
        {
            Debug.Assert(typeof(TArgument) == typeof(<#=naming.ArgumentType#>));
            client.<#=naming.EventName#> += (AsyncEventHandler<DiscordClient, <#=naming.ArgumentType#>>)handler;
            return;
        }
        else
<#}#>
        {
            Debug.Fail($"Not a supported type: {typeof(THandlerInterface).Name}");
            throw new InvalidOperationException($"Handler of type {typeof(THandlerInterface).Name} not supported");
        }
    }

    public static partial void UnbindEvent<THandlerInterface, TArgument>(DiscordShardedClient client, AsyncEventHandler<DiscordClient, TArgument> handler) where THandlerInterface : IDiscordEventHandler<TArgument> where TArgument : DiscordEventArgs
    {
<# foreach(EventNaming naming in EventsList) { #>
        if(typeof(THandlerInterface) == typeof(<#=naming.InterfaceName#>))
        {
            Debug.Assert(typeof(TArgument) == typeof(<#=naming.ArgumentType#>));
            client.<#=naming.EventName#> -= (AsyncEventHandler<DiscordClient, <#=naming.ArgumentType#>>)handler;
            return;
        }
        else
<#}#>
        {
            Debug.Fail($"Not a supported type: {typeof(THandlerInterface).Name}");
            throw new InvalidOperationException($"Handler of type {typeof(THandlerInterface).Name} not supported");
        }
    }
}