<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ include file="../../DiscordEventsTemplateBase.tt" #>
using System;
using System.Diagnostics;
using DSharpPlus.EventsNext.Entities;

<#=AutomaticNamespaceLine#>

internal static partial class HandlerValidation
{
    public static partial bool IsHandlerCanidate<THandler>(out string reason) where THandler : IDiscordEventHandler
    {
<# WriteOperation(isGeneric: true, "THandler"); #>

    public static partial bool IsHandlerCanidate(Type handlerType, out string reason)
    {
        Debug.Assert(handlerType != null);
<# WriteOperation(isGeneric: false, "handlerType"); #>
}

<#+
    public void WriteOperation(bool isGeneric, string argumentName)
    {
        string wrappedArgument = isGeneric ? $"typeof({argumentName})" : argumentName;
#>
        if (!<#=wrappedArgument#>.IsClass)
        {
            reason = $"Type {<#=wrappedArgument#>.Name} is not a class implementing {nameof(IDiscordEventHandler)}";
            return false;
        }

        if (<#=wrappedArgument#>.IsAbstract)
        {
            reason = $"Type {<#=wrappedArgument#>.Name} is abstract, which is not allowed";
            return false;
        }

        if (!<#=wrappedArgument#>.IsAssignableTo(typeof(IDiscordEventHandler)))
        {
            reason = $"Type {<#=wrappedArgument#>.Name} is not a {nameof(IDiscordEventHandler)}";
            return false;
        }
        
        if (!EventInterfaceValidation.IsAssignableToAny<#=isGeneric ? $"<{argumentName}>(" : $"({argumentName}"#>))
        {
            reason = $"Handler {<#=wrappedArgument#>.Name} is not assignable to any of the handler interfaces";
            return false;
        }

        reason = string.Empty;
        return true;
    }
<#+
    }
#>