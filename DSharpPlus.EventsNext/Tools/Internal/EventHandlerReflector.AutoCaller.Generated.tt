<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ include file="../../../DiscordEventsTemplateBase.tt" #>
<#@ assembly name="System.Core" #>
using DSharpPlus.EventArgs;
using System.Diagnostics;
using System.Threading.Tasks;
using DSharpPlus.EventsNext.Entities;
using System;

namespace <#=AutomaticNamespace#>;

internal partial class EventHandlerReflector
{
    public static partial ValueTask AutoCallEventHandler<THandler, TArgument>(IDiscordEventHandler<TArgument> handler, DiscordClient sender, TArgument args) where THandler : IDiscordEventHandler<TArgument> where TArgument : DiscordEventArgs
    {
<# foreach(EventNaming naming in EventsList) { #>
        if(typeof(THandler) == typeof(<#=naming.InterfaceName#>))
        {
            Debug.Assert(typeof(TArgument) == typeof(<#=naming.ArgumentType#>));
            <#=naming.InterfaceName#> castHandler = (<#=naming.InterfaceName#>)handler;
            <#=naming.ArgumentType#> castArgs = (<#=naming.ArgumentType#>)(DiscordEventArgs)args;
            return castHandler.<#=naming.MethodName#>(sender, castArgs);
        }
        else
<#}#>
        {
            Debug.Fail($"Not a supported type: {typeof(THandler).Name}");
            return ValueTask.FromException(new InvalidOperationException($"Handler of type {typeof(THandler).Name} not supported"));
        }
    }
}