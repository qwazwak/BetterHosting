<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ assembly name="System.Net.Http" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#if false
#nullable enable
#define AsyncManualResetEventNoValue
<#
Setup();
RemoveLines("#define AsyncManualResetEventWithValue");
RemoveWhere(l => l.Contains("@@AsyncManualResetEventWithValue@@"));
RemoveWhere(l => l.Trim() == "this.value = value;");
RemoveWhere(l => l.Trim() == "value = default!;");
ReplaceSubString("ValueTask.FromResult(value!)", "ValueTask.CompletedTask");
ReplaceSubString("ValueTask.FromResult(value)", "ValueTask.CompletedTask");
substringsToRemove.ForEach(sr => ReplaceSubString(sr, string.Empty));

{
    string all = string.Join(Environment.NewLine, sourceLines);
    
    Regex TMatch = new(@" *#if AsyncManualResetEventWithValue\r?\n(?:(?:\r?\n|.*?)*?)(?:#else\r?\n((?:\r?\n|.*?)*?))?#endif\r?\n");
    all = TMatch.Replace(all, "$1");
    sourceLines = new(Regex.Split(all, Environment.NewLine));
}
{
    Regex TMatch = new("<T>|{T}");
    for (int i = 0; i < sourceLines.Count; i++)
        sourceLines[i] = TMatch.Replace(sourceLines[i], string.Empty);
}
{
    //ReplaceOne("internal sealed class AsyncManualResetEvent", "internal sealed partial class AsyncManualResetEvent");
}

#>
<# //Print bulk
sourceLines.ForEach(WriteLine);
#>
#endif
<#+
    // Config
    const string GenericFileName = "AsyncManualResetEventGeneric.cs";

    List<string> substringsToRemove = new()
    {
        "<T>",
        "T value",
        "value",
        "{T}"
    };
    // end config
        
    List<string> sourceLines;

    //helpers: 
    void Setup()
    {
        string CurrentDir = Host.ResolvePath(string.Empty);
        string SourceFile = Path.Combine(CurrentDir, GenericFileName);
        sourceLines = new(File.ReadAllLines(SourceFile));
    }


    void MutateLines(Func<string, string> mutate)
    {
        for (int i = 0; i < sourceLines.Count; i++)
            sourceLines[i] = mutate(sourceLines[i]);
    }
    void MutateLines(Predicate<string> match, Func<string, string> mutate) => MutateLines(l => match(l) ? mutate(l) : l);
    void MutateLines(Predicate<string> match, string newValue) => MutateLines(match, o => newValue);
    void ReplaceLines(string match, string newValue) => MutateLines(s => s == match ? newValue : s);
    void RemoveLines(string match) => ReplaceLines(match, string.Empty);
    void ReplaceSubString(string substringMatch, string substringInsert) => MutateLines(s => s.Replace(substringMatch, substringInsert));

    void RemoveWhere(Predicate<string> match) => sourceLines.RemoveAll(match);
    void ReplaceOne(string match, string newValue)
    {
        int index = sourceLines.IndexOf(match);
        if(index == -1)
        throw new ArgumentException($"The string {match} was not found in the source", match);
        sourceLines[index] = newValue;
    }
#>